{"ast":null,"code":"// src/algorithms.js\n\n/**\n * Node structure assumption:\n * {\n *   row, col,\n *   isWall, isVisited,\n *   distance (for Dijkstra), gCost, hCost, fCost (for A*),\n *   previousNode,\n * }\n *\n * grid is a 2D array: grid[row][col].\n */\n\n/////////////////////////////\n//  BFS\n/////////////////////////////\nexport function bfs(grid, startNode, endNode) {\n  const queue = [];\n  const visitedNodesInOrder = [];\n  startNode.isVisited = true;\n  queue.push(startNode);\n  while (queue.length > 0) {\n    const currentNode = queue.shift();\n    if (!currentNode || currentNode.isWall) continue;\n    visitedNodesInOrder.push(currentNode);\n    if (currentNode === endNode) {\n      const path = reconstructPath(endNode);\n      return {\n        visitedNodesInOrder,\n        path\n      };\n    }\n    const neighbors = getNeighbors(grid, currentNode);\n    for (const neighbor of neighbors) {\n      if (!neighbor.isVisited && !neighbor.isWall) {\n        neighbor.isVisited = true;\n        neighbor.previousNode = currentNode;\n        queue.push(neighbor);\n      }\n    }\n  }\n  return {\n    visitedNodesInOrder,\n    path: []\n  };\n}\n\n/////////////////////////////\n//  DFS\n/////////////////////////////\nexport function dfs(grid, startNode, endNode) {\n  const stack = [];\n  const visitedNodesInOrder = [];\n  startNode.isVisited = true;\n  stack.push(startNode);\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    if (!currentNode || currentNode.isWall) continue;\n    visitedNodesInOrder.push(currentNode);\n    if (currentNode === endNode) {\n      const path = reconstructPath(endNode);\n      return {\n        visitedNodesInOrder,\n        path\n      };\n    }\n    const neighbors = getNeighbors(grid, currentNode);\n    for (const neighbor of neighbors) {\n      if (!neighbor.isVisited && !neighbor.isWall) {\n        neighbor.isVisited = true;\n        neighbor.previousNode = currentNode;\n        stack.push(neighbor);\n      }\n    }\n  }\n  return {\n    visitedNodesInOrder,\n    path: []\n  };\n}\n\n/////////////////////////////\n//  Dijkstra\n/////////////////////////////\nexport function dijkstra(grid, startNode, endNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (unvisitedNodes.length) {\n    // Sort by distance\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    const closestNode = unvisitedNodes.shift();\n    if (!closestNode || closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) {\n      // No path found\n      return {\n        visitedNodesInOrder,\n        path: []\n      };\n    }\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === endNode) {\n      const path = reconstructPath(endNode);\n      return {\n        visitedNodesInOrder,\n        path\n      };\n    }\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n  return {\n    visitedNodesInOrder,\n    path: []\n  };\n}\nfunction updateUnvisitedNeighbors(node, grid) {\n  const neighbors = getNeighbors(grid, node);\n  for (const neighbor of neighbors) {\n    if (neighbor.isVisited || neighbor.isWall) continue;\n    const altDist = node.distance + 1;\n    if (altDist < neighbor.distance) {\n      neighbor.distance = altDist;\n      neighbor.previousNode = node;\n    }\n  }\n}\n\n/////////////////////////////\n//  A*\n/////////////////////////////\nexport function aStar(grid, startNode, endNode) {\n  const openSet = [];\n  const visitedNodesInOrder = [];\n  startNode.gCost = 0;\n  startNode.hCost = heuristic(startNode, endNode);\n  startNode.fCost = startNode.gCost + startNode.hCost;\n  openSet.push(startNode);\n  while (openSet.length) {\n    openSet.sort((a, b) => a.fCost - b.fCost);\n    const current = openSet.shift();\n    if (!current || current.isWall) continue;\n    current.isVisited = true;\n    visitedNodesInOrder.push(current);\n    if (current === endNode) {\n      const path = reconstructPath(endNode);\n      return {\n        visitedNodesInOrder,\n        path\n      };\n    }\n    const neighbors = getNeighbors(grid, current);\n    for (const neighbor of neighbors) {\n      if (neighbor.isVisited || neighbor.isWall) continue;\n      const tentativeG = current.gCost + 1;\n      if (tentativeG < neighbor.gCost) {\n        neighbor.gCost = tentativeG;\n        neighbor.hCost = heuristic(neighbor, endNode);\n        neighbor.fCost = neighbor.gCost + neighbor.hCost;\n        neighbor.previousNode = current;\n        if (!openSet.includes(neighbor)) {\n          openSet.push(neighbor);\n        }\n      }\n    }\n  }\n  return {\n    visitedNodesInOrder: visitedNodesInOrder,\n    path: []\n  };\n}\n\n/////////////////////////////\n//  Helper Functions\n/////////////////////////////\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\nfunction getNeighbors(grid, node) {\n  const {\n    row,\n    col\n  } = node;\n  const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n  const neighbors = [];\n  for (const [dr, dc] of directions) {\n    const nr = row + dr;\n    const nc = col + dc;\n    if (nr >= 0 && nr < grid.length && nc >= 0 && nc < grid[0].length) {\n      neighbors.push(grid[nr][nc]);\n    }\n  }\n  return neighbors;\n}\nfunction heuristic(a, b) {\n  return Math.abs(a.row - b.row) + Math.abs(a.col - b.col);\n}\nfunction reconstructPath(endNode) {\n  const path = [];\n  let current = endNode;\n  while (current) {\n    path.unshift(current);\n    current = current.previousNode;\n  }\n  return path;\n}","map":{"version":3,"names":["bfs","grid","startNode","endNode","queue","visitedNodesInOrder","isVisited","push","length","currentNode","shift","isWall","path","reconstructPath","neighbors","getNeighbors","neighbor","previousNode","dfs","stack","pop","dijkstra","distance","unvisitedNodes","getAllNodes","sort","a","b","closestNode","Infinity","updateUnvisitedNeighbors","node","altDist","aStar","openSet","gCost","hCost","heuristic","fCost","current","tentativeG","includes","nodes","row","col","directions","dr","dc","nr","nc","Math","abs","unshift"],"sources":["/Users/jinaldave/Projects/pathfinder/src/algorithms.js"],"sourcesContent":["// src/algorithms.js\n\n/**\n * Node structure assumption:\n * {\n *   row, col,\n *   isWall, isVisited,\n *   distance (for Dijkstra), gCost, hCost, fCost (for A*),\n *   previousNode,\n * }\n *\n * grid is a 2D array: grid[row][col].\n */\n\n/////////////////////////////\n//  BFS\n/////////////////////////////\nexport function bfs(grid, startNode, endNode) {\n  const queue = [];\n  const visitedNodesInOrder = [];\n\n  startNode.isVisited = true;\n  queue.push(startNode);\n\n  while (queue.length > 0) {\n    const currentNode = queue.shift();\n    if (!currentNode || currentNode.isWall) continue;\n\n    visitedNodesInOrder.push(currentNode);\n\n    if (currentNode === endNode) {\n      const path = reconstructPath(endNode);\n      return { visitedNodesInOrder, path };\n    }\n\n    const neighbors = getNeighbors(grid, currentNode);\n    for (const neighbor of neighbors) {\n      if (!neighbor.isVisited && !neighbor.isWall) {\n        neighbor.isVisited = true;\n        neighbor.previousNode = currentNode;\n        queue.push(neighbor);\n      }\n    }\n  }\n\n  return { visitedNodesInOrder, path: [] };\n}\n\n/////////////////////////////\n//  DFS\n/////////////////////////////\nexport function dfs(grid, startNode, endNode) {\n  const stack = [];\n  const visitedNodesInOrder = [];\n\n  startNode.isVisited = true;\n  stack.push(startNode);\n\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    if (!currentNode || currentNode.isWall) continue;\n\n    visitedNodesInOrder.push(currentNode);\n\n    if (currentNode === endNode) {\n      const path = reconstructPath(endNode);\n      return { visitedNodesInOrder, path };\n    }\n\n    const neighbors = getNeighbors(grid, currentNode);\n    for (const neighbor of neighbors) {\n      if (!neighbor.isVisited && !neighbor.isWall) {\n        neighbor.isVisited = true;\n        neighbor.previousNode = currentNode;\n        stack.push(neighbor);\n      }\n    }\n  }\n\n  return { visitedNodesInOrder, path: [] };\n}\n\n/////////////////////////////\n//  Dijkstra\n/////////////////////////////\nexport function dijkstra(grid, startNode, endNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (unvisitedNodes.length) {\n    // Sort by distance\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    const closestNode = unvisitedNodes.shift();\n    if (!closestNode || closestNode.isWall) continue;\n\n    if (closestNode.distance === Infinity) {\n      // No path found\n      return { visitedNodesInOrder, path: [] };\n    }\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n\n    if (closestNode === endNode) {\n      const path = reconstructPath(endNode);\n      return { visitedNodesInOrder, path };\n    }\n\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n\n  return { visitedNodesInOrder, path: [] };\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const neighbors = getNeighbors(grid, node);\n  for (const neighbor of neighbors) {\n    if (neighbor.isVisited || neighbor.isWall) continue;\n    const altDist = node.distance + 1;\n    if (altDist < neighbor.distance) {\n      neighbor.distance = altDist;\n      neighbor.previousNode = node;\n    }\n  }\n}\n\n/////////////////////////////\n//  A*\n/////////////////////////////\nexport function aStar(grid, startNode, endNode) {\n  const openSet = [];\n  const visitedNodesInOrder = [];\n\n  startNode.gCost = 0;\n  startNode.hCost = heuristic(startNode, endNode);\n  startNode.fCost = startNode.gCost + startNode.hCost;\n  openSet.push(startNode);\n\n  while (openSet.length) {\n    openSet.sort((a, b) => a.fCost - b.fCost);\n    const current = openSet.shift();\n    if (!current || current.isWall) continue;\n\n    current.isVisited = true;\n    visitedNodesInOrder.push(current);\n\n    if (current === endNode) {\n      const path = reconstructPath(endNode);\n      return { visitedNodesInOrder, path };\n    }\n\n    const neighbors = getNeighbors(grid, current);\n    for (const neighbor of neighbors) {\n      if (neighbor.isVisited || neighbor.isWall) continue;\n      const tentativeG = current.gCost + 1;\n      if (tentativeG < neighbor.gCost) {\n        neighbor.gCost = tentativeG;\n        neighbor.hCost = heuristic(neighbor, endNode);\n        neighbor.fCost = neighbor.gCost + neighbor.hCost;\n        neighbor.previousNode = current;\n        if (!openSet.includes(neighbor)) {\n          openSet.push(neighbor);\n        }\n      }\n    }\n  }\n\n  return { visitedNodesInOrder: visitedNodesInOrder, path: [] };\n}\n\n/////////////////////////////\n//  Helper Functions\n/////////////////////////////\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nfunction getNeighbors(grid, node) {\n  const { row, col } = node;\n  const directions = [\n    [0, 1],\n    [0, -1],\n    [1, 0],\n    [-1, 0],\n  ];\n  const neighbors = [];\n  for (const [dr, dc] of directions) {\n    const nr = row + dr;\n    const nc = col + dc;\n    if (nr >= 0 && nr < grid.length && nc >= 0 && nc < grid[0].length) {\n      neighbors.push(grid[nr][nc]);\n    }\n  }\n  return neighbors;\n}\n\nfunction heuristic(a, b) {\n  return Math.abs(a.row - b.row) + Math.abs(a.col - b.col);\n}\n\nfunction reconstructPath(endNode) {\n  const path = [];\n  let current = endNode;\n  while (current) {\n    path.unshift(current);\n    current = current.previousNode;\n  }\n  return path;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}