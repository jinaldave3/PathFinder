{"ast":null,"code":"export function aStar(grid, startNode, endNode) {\n  // Initialize openSet with the start node\n  const openSet = [];\n  startNode.gCost = 0;\n  startNode.hCost = heuristic(startNode, endNode);\n  startNode.fCost = startNode.hCost;\n  openSet.push(startNode);\n  const visitedNodesInOrder = []; // For visualization\n\n  while (openSet.length > 0) {\n    // Sort openSet by fCost to simulate priority queue\n    openSet.sort((a, b) => a.fCost - b.fCost);\n    const currentNode = openSet.shift();\n\n    // If we hit a wall or something unexpected, skip\n    if (!currentNode || currentNode.isWall) continue;\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n\n    // If currentNode is the endNode, construct the path\n    if (currentNode === endNode) {\n      return {\n        visitedNodesInOrder,\n        path: reconstructPath(endNode)\n      };\n    }\n\n    // Check neighbors\n    const neighbors = getNeighbors(currentNode, grid);\n    for (const neighbor of neighbors) {\n      if (neighbor.isVisited || neighbor.isWall) continue;\n      const tentativeG = currentNode.gCost + 1; // cost of 1 to move to neighbor\n      if (tentativeG < neighbor.gCost) {\n        neighbor.previousNode = currentNode;\n        neighbor.gCost = tentativeG;\n        neighbor.hCost = heuristic(neighbor, endNode);\n        neighbor.fCost = neighbor.gCost + neighbor.hCost;\n        if (!openSet.includes(neighbor)) {\n          openSet.push(neighbor);\n        }\n      }\n    }\n  }\n  // If no path found\n  return {\n    visitedNodesInOrder,\n    path: []\n  };\n}\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    row,\n    col\n  } = node;\n  const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n  for (const [dr, dc] of directions) {\n    const newRow = row + dr;\n    const newCol = col + dc;\n    if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length) {\n      neighbors.push(grid[newRow][newCol]);\n    }\n  }\n  return neighbors;\n}\n\n// Simple manhattan distance for heuristic\nfunction heuristic(a, b) {\n  const dx = Math.abs(a.row - b.row);\n  const dy = Math.abs(a.col - b.col);\n  return dx + dy;\n}\nfunction reconstructPath(endNode) {\n  const path = [];\n  let current = endNode;\n  while (current) {\n    path.unshift(current);\n    current = current.previousNode;\n  }\n  return path;\n}","map":{"version":3,"names":["aStar","grid","startNode","endNode","openSet","gCost","hCost","heuristic","fCost","push","visitedNodesInOrder","length","sort","a","b","currentNode","shift","isWall","isVisited","path","reconstructPath","neighbors","getNeighbors","neighbor","tentativeG","previousNode","includes","node","row","col","directions","dr","dc","newRow","newCol","dx","Math","abs","dy","current","unshift"],"sources":["/Users/jinaldave/Projects/pathfinder/src/astar.js"],"sourcesContent":["\nexport function aStar(grid, startNode, endNode) {\n  // Initialize openSet with the start node\n  const openSet = [];\n  startNode.gCost = 0;\n  startNode.hCost = heuristic(startNode, endNode);\n  startNode.fCost = startNode.hCost;\n  openSet.push(startNode);\n\n  const visitedNodesInOrder = []; // For visualization\n\n  while (openSet.length > 0) {\n    // Sort openSet by fCost to simulate priority queue\n    openSet.sort((a, b) => a.fCost - b.fCost);\n    const currentNode = openSet.shift();\n\n    // If we hit a wall or something unexpected, skip\n    if (!currentNode || currentNode.isWall) continue;\n\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n\n    // If currentNode is the endNode, construct the path\n    if (currentNode === endNode) {\n      return { visitedNodesInOrder, path: reconstructPath(endNode) };\n    }\n\n    // Check neighbors\n    const neighbors = getNeighbors(currentNode, grid);\n    for (const neighbor of neighbors) {\n      if (neighbor.isVisited || neighbor.isWall) continue;\n\n      const tentativeG = currentNode.gCost + 1; // cost of 1 to move to neighbor\n      if (tentativeG < neighbor.gCost) {\n        neighbor.previousNode = currentNode;\n        neighbor.gCost = tentativeG;\n        neighbor.hCost = heuristic(neighbor, endNode);\n        neighbor.fCost = neighbor.gCost + neighbor.hCost;\n\n        if (!openSet.includes(neighbor)) {\n          openSet.push(neighbor);\n        }\n      }\n    }\n  }\n  // If no path found\n  return { visitedNodesInOrder, path: [] };\n}\n\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n  const directions = [\n    [0, 1],\n    [0, -1],\n    [1, 0],\n    [-1, 0],\n  ];\n\n  for (const [dr, dc] of directions) {\n    const newRow = row + dr;\n    const newCol = col + dc;\n    if (\n      newRow >= 0 &&\n      newRow < grid.length &&\n      newCol >= 0 &&\n      newCol < grid[0].length\n    ) {\n      neighbors.push(grid[newRow][newCol]);\n    }\n  }\n  return neighbors;\n}\n\n// Simple manhattan distance for heuristic\nfunction heuristic(a, b) {\n  const dx = Math.abs(a.row - b.row);\n  const dy = Math.abs(a.col - b.col);\n  return dx + dy;\n}\n\nfunction reconstructPath(endNode) {\n  const path = [];\n  let current = endNode;\n  while (current) {\n    path.unshift(current);\n    current = current.previousNode;\n  }\n  return path;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}