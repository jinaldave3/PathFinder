{"ast":null,"code":"var _jsxFileName = \"/Users/jinaldave/Projects/pathfinder/src/PathfindingVisualizer.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport './Node.css';\nimport { bfs, dfs, dijkstra, aStar } from './algorithms';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ALGORITHMS = [{\n  label: 'BFS',\n  value: 'bfs'\n}, {\n  label: 'DFS',\n  value: 'dfs'\n}, {\n  label: 'Dijkstra',\n  value: 'dijkstra'\n}, {\n  label: 'A*',\n  value: 'astar'\n}];\nexport default function PathfindingVisualizer() {\n  _s();\n  // Grid size\n  const [numRows, setNumRows] = useState(20);\n  const [numCols, setNumCols] = useState(40);\n\n  // Positions for start (green) and end (red)\n  const [startPos, setStartPos] = useState({\n    row: 5,\n    col: 5\n  });\n  const [endPos, setEndPos] = useState({\n    row: 15,\n    col: 30\n  });\n  const [grid, setGrid] = useState([]);\n  const [selectedAlgorithm, setSelectedAlgorithm] = useState('bfs');\n  const [isRunning, setIsRunning] = useState(false);\n  const [speed, setSpeed] = useState(5); // 1 is fastest, 10 slowest\n\n  // Track drag states for start/end nodes\n  const isDraggingStart = useRef(false);\n  const isDraggingEnd = useRef(false);\n  useEffect(() => {\n    // Whenever numRows or numCols changes, clamp start/end if needed, then rebuild grid\n    clampNodePositions();\n    resetGrid();\n    // eslint-disable-next-line\n  }, [numRows, numCols]);\n\n  // Ensure start/end positions are valid in the new grid size\n  function clampNodePositions() {\n    // Clamp end node\n    if (endPos.row >= numRows) {\n      setEndPos(prev => ({\n        ...prev,\n        row: numRows - 1\n      }));\n    }\n    if (endPos.col >= numCols) {\n      setEndPos(prev => ({\n        ...prev,\n        col: numCols - 1\n      }));\n    }\n\n    // Clamp start node\n    if (startPos.row >= numRows) {\n      setStartPos(prev => ({\n        ...prev,\n        row: numRows - 1\n      }));\n    }\n    if (startPos.col >= numCols) {\n      setStartPos(prev => ({\n        ...prev,\n        col: numCols - 1\n      }));\n    }\n  }\n  function resetGrid() {\n    const newGrid = [];\n    for (let row = 0; row < numRows; row++) {\n      const currentRow = [];\n      for (let col = 0; col < numCols; col++) {\n        currentRow.push(createNode(row, col));\n      }\n      newGrid.push(currentRow);\n    }\n    setGrid(newGrid);\n  }\n  function createNode(row, col) {\n    return {\n      row,\n      col,\n      isStart: row === startPos.row && col === startPos.col,\n      isEnd: row === endPos.row && col === endPos.col,\n      isWall: false,\n      isVisited: false,\n      distance: Infinity,\n      gCost: Infinity,\n      hCost: Infinity,\n      fCost: Infinity,\n      previousNode: null\n    };\n  }\n  function handleColsChange(newCols) {\n    // Just parse the input, set state\n    const cols = parseInt(newCols, 10);\n    if (cols < 5) return; // min limit\n    setNumCols(cols);\n  }\n  function handleRowsChange(newRows) {\n    const rows = parseInt(newRows, 10);\n    if (rows < 5) return; // min limit\n    setNumRows(rows);\n  }\n\n  // Clear path states (visited, path)\n  function clearPath() {\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const nodeDiv = document.getElementById(`node-${row}-${col}`);\n        if (nodeDiv) {\n          nodeDiv.classList.remove('node-visited');\n          nodeDiv.classList.remove('node-path');\n        }\n      }\n    }\n    const newGrid = grid.slice();\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const node = newGrid[row][col];\n        node.isVisited = false;\n        node.distance = Infinity;\n        node.gCost = Infinity;\n        node.hCost = Infinity;\n        node.fCost = Infinity;\n        node.previousNode = null;\n      }\n    }\n    setGrid(newGrid);\n  }\n\n  // Visualize selected algorithm\n  function visualize() {\n    setIsRunning(true);\n    clearPath();\n    const startNode = grid[startPos.row][startPos.col];\n    const endNode = grid[endPos.row][endPos.col];\n    let visitedNodesInOrder = [];\n    let path = [];\n\n    // Run the selected algorithm\n    switch (selectedAlgorithm) {\n      case 'dfs':\n        ({\n          visitedNodesInOrder,\n          path\n        } = dfs(grid, startNode, endNode));\n        break;\n      case 'dijkstra':\n        ({\n          visitedNodesInOrder,\n          path\n        } = dijkstra(grid, startNode, endNode));\n        break;\n      case 'astar':\n        ({\n          visitedNodesInOrder,\n          path\n        } = aStar(grid, startNode, endNode));\n        break;\n      case 'bfs':\n      default:\n        ({\n          visitedNodesInOrder,\n          path\n        } = bfs(grid, startNode, endNode));\n        break;\n    }\n    animateVisited(visitedNodesInOrder, path);\n  }\n  function animateVisited(visitedNodesInOrder, path) {\n    // Delay depends on speed (lower speed => bigger delay)\n    const visitDelay = 105 - speed * 10;\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animatePath(path);\n        }, visitDelay * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeDiv = document.getElementById(`node-${node.row}-${node.col}`);\n        if (nodeDiv) {\n          nodeDiv.classList.add('node-visited');\n        }\n      }, visitDelay * i);\n    }\n  }\n  function animatePath(path) {\n    const pathDelay = 150 - speed * 15;\n    for (let i = 0; i < path.length; i++) {\n      setTimeout(() => {\n        const node = path[i];\n        const nodeDiv = document.getElementById(`node-${node.row}-${node.col}`);\n        if (nodeDiv) {\n          nodeDiv.classList.remove('node-visited');\n          nodeDiv.classList.add('node-path');\n        }\n        // Unlock the UI at the end\n        if (i === path.length - 1) {\n          setIsRunning(false);\n        }\n      }, pathDelay * i);\n    }\n\n    // If path is empty, no final unlocking\n    if (!path.length) {\n      setIsRunning(false);\n    }\n  }\n\n  /************************************************\n   * Wall toggling and dragging start/end node\n   ************************************************/\n  const handleMouseDown = (row, col) => {\n    if (isRunning) return;\n    const node = grid[row][col];\n    // If clicking on start or end => drag mode\n    if (node.isStart) {\n      isDraggingStart.current = true;\n    } else if (node.isEnd) {\n      isDraggingEnd.current = true;\n    } else {\n      // Toggle wall\n      toggleWall(row, col);\n    }\n  };\n  const handleMouseEnter = (row, col) => {\n    if (isRunning) return;\n    if (isDraggingStart.current) {\n      moveStart(row, col);\n    } else if (isDraggingEnd.current) {\n      moveEnd(row, col);\n    }\n  };\n  const handleMouseUp = () => {\n    isDraggingStart.current = false;\n    isDraggingEnd.current = false;\n  };\n  function toggleWall(row, col) {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    if (!node.isStart && !node.isEnd) {\n      node.isWall = !node.isWall;\n    }\n    setGrid(newGrid);\n  }\n  function moveStart(row, col) {\n    if (row === endPos.row && col === endPos.col) return; // can't overlap\n    const newGrid = grid.slice();\n    // Remove old start\n    newGrid[startPos.row][startPos.col].isStart = false;\n    newGrid[startPos.row][startPos.col].isWall = false;\n    // Set new start\n    newGrid[row][col].isStart = true;\n    newGrid[row][col].isWall = false;\n    setStartPos({\n      row,\n      col\n    });\n    setGrid(newGrid);\n  }\n  function moveEnd(row, col) {\n    if (row === startPos.row && col === startPos.col) return; // can't overlap\n    const newGrid = grid.slice();\n    // Remove old end\n    newGrid[endPos.row][endPos.col].isEnd = false;\n    newGrid[endPos.row][endPos.col].isWall = false;\n    // Set new end\n    newGrid[row][col].isEnd = true;\n    newGrid[row][col].isWall = false;\n    setEndPos({\n      row,\n      col\n    });\n    setGrid(newGrid);\n  }\n\n  // Render the grid with event handlers\n  function renderGrid() {\n    return grid.map((rowArray, rowIdx) => {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"row\",\n        children: rowArray.map((node, colIdx) => {\n          const {\n            row,\n            col,\n            isWall,\n            isStart,\n            isEnd\n          } = node;\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            id: `node-${row}-${col}`,\n            className: `node\n                  ${isWall ? 'node-wall' : ''}\n                  ${isStart ? 'node-start' : ''}\n                  ${isEnd ? 'node-end' : ''}\n                `,\n            onMouseDown: () => handleMouseDown(row, col),\n            onMouseEnter: () => handleMouseEnter(row, col),\n            onMouseUp: handleMouseUp\n          }, colIdx, false, {\n            fileName: _jsxFileName,\n            lineNumber: 272,\n            columnNumber: 15\n          }, this);\n        })\n      }, rowIdx, false, {\n        fileName: _jsxFileName,\n        lineNumber: 268,\n        columnNumber: 9\n      }, this);\n    });\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      textAlign: 'center'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Pathfinder\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 293,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        margin: '10px 0'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        children: [\"Rows:\", /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          min: \"5\",\n          max: \"50\",\n          value: numRows,\n          onChange: e => handleRowsChange(e.target.value),\n          disabled: isRunning,\n          style: {\n            width: '60px',\n            margin: '0 8px'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 299,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 297,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n        children: [\"Cols:\", /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          min: \"5\",\n          max: \"60\",\n          value: numCols,\n          onChange: e => handleColsChange(e.target.value),\n          disabled: isRunning,\n          style: {\n            width: '60px',\n            margin: '0 8px'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 311,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 309,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 296,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        margin: '10px 0'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        children: [\"Algorithm:\", /*#__PURE__*/_jsxDEV(\"select\", {\n          value: selectedAlgorithm,\n          onChange: e => setSelectedAlgorithm(e.target.value),\n          disabled: isRunning,\n          style: {\n            margin: '0 8px'\n          },\n          children: ALGORITHMS.map(algo => /*#__PURE__*/_jsxDEV(\"option\", {\n            value: algo.value,\n            children: algo.label\n          }, algo.value, false, {\n            fileName: _jsxFileName,\n            lineNumber: 334,\n            columnNumber: 15\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 327,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 325,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n        children: [\"Speed:\", /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"range\",\n          min: \"1\",\n          max: \"10\",\n          value: speed,\n          onChange: e => setSpeed(parseInt(e.target.value)),\n          disabled: isRunning,\n          style: {\n            margin: '0 8px'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 343,\n          columnNumber: 11\n        }, this), speed]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 341,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 324,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: resetGrid,\n      disabled: isRunning,\n      children: \"Reset Grid\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 357,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: clearPath,\n      disabled: isRunning,\n      children: \"Clear Path\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 360,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: visualize,\n      disabled: isRunning,\n      children: \"Visualize\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 363,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginTop: '20px',\n        display: 'inline-block'\n      },\n      children: renderGrid()\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 368,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 292,\n    columnNumber: 5\n  }, this);\n}\n_s(PathfindingVisualizer, \"FLQSYPWXnVFPYC+BJEmSUON2n3M=\");\n_c = PathfindingVisualizer;\nvar _c;\n$RefreshReg$(_c, \"PathfindingVisualizer\");","map":{"version":3,"names":["React","useState","useEffect","useRef","bfs","dfs","dijkstra","aStar","jsxDEV","_jsxDEV","ALGORITHMS","label","value","PathfindingVisualizer","_s","numRows","setNumRows","numCols","setNumCols","startPos","setStartPos","row","col","endPos","setEndPos","grid","setGrid","selectedAlgorithm","setSelectedAlgorithm","isRunning","setIsRunning","speed","setSpeed","isDraggingStart","isDraggingEnd","clampNodePositions","resetGrid","prev","newGrid","currentRow","push","createNode","isStart","isEnd","isWall","isVisited","distance","Infinity","gCost","hCost","fCost","previousNode","handleColsChange","newCols","cols","parseInt","handleRowsChange","newRows","rows","clearPath","nodeDiv","document","getElementById","classList","remove","slice","node","visualize","startNode","endNode","visitedNodesInOrder","path","animateVisited","visitDelay","i","length","setTimeout","animatePath","add","pathDelay","handleMouseDown","current","toggleWall","handleMouseEnter","moveStart","moveEnd","handleMouseUp","renderGrid","map","rowArray","rowIdx","className","children","colIdx","id","onMouseDown","onMouseEnter","onMouseUp","fileName","_jsxFileName","lineNumber","columnNumber","style","textAlign","margin","type","min","max","onChange","e","target","disabled","width","algo","onClick","marginTop","display","_c","$RefreshReg$"],"sources":["/Users/jinaldave/Projects/pathfinder/src/PathfindingVisualizer.js"],"sourcesContent":["\nimport React, { useState, useEffect, useRef } from 'react';\nimport './Node.css';\nimport { bfs, dfs, dijkstra, aStar } from './algorithms';\n\nconst ALGORITHMS = [\n  { label: 'BFS', value: 'bfs' },\n  { label: 'DFS', value: 'dfs' },\n  { label: 'Dijkstra', value: 'dijkstra' },\n  { label: 'A*', value: 'astar' },\n];\n\nexport default function PathfindingVisualizer() {\n  // Grid size\n  const [numRows, setNumRows] = useState(20);\n  const [numCols, setNumCols] = useState(40);\n\n  // Positions for start (green) and end (red)\n  const [startPos, setStartPos] = useState({ row: 5, col: 5 });\n  const [endPos, setEndPos] = useState({ row: 15, col: 30 });\n\n  const [grid, setGrid] = useState([]);\n  const [selectedAlgorithm, setSelectedAlgorithm] = useState('bfs');\n  const [isRunning, setIsRunning] = useState(false);\n  const [speed, setSpeed] = useState(5); // 1 is fastest, 10 slowest\n\n  // Track drag states for start/end nodes\n  const isDraggingStart = useRef(false);\n  const isDraggingEnd = useRef(false);\n\n  useEffect(() => {\n    // Whenever numRows or numCols changes, clamp start/end if needed, then rebuild grid\n    clampNodePositions();\n    resetGrid();\n    // eslint-disable-next-line\n  }, [numRows, numCols]);\n\n  // Ensure start/end positions are valid in the new grid size\n  function clampNodePositions() {\n    // Clamp end node\n    if (endPos.row >= numRows) {\n      setEndPos((prev) => ({ ...prev, row: numRows - 1 }));\n    }\n    if (endPos.col >= numCols) {\n      setEndPos((prev) => ({ ...prev, col: numCols - 1 }));\n    }\n\n    // Clamp start node\n    if (startPos.row >= numRows) {\n      setStartPos((prev) => ({ ...prev, row: numRows - 1 }));\n    }\n    if (startPos.col >= numCols) {\n      setStartPos((prev) => ({ ...prev, col: numCols - 1 }));\n    }\n  }\n\n  function resetGrid() {\n    const newGrid = [];\n    for (let row = 0; row < numRows; row++) {\n      const currentRow = [];\n      for (let col = 0; col < numCols; col++) {\n        currentRow.push(createNode(row, col));\n      }\n      newGrid.push(currentRow);\n    }\n    setGrid(newGrid);\n  }\n\n  function createNode(row, col) {\n    return {\n      row,\n      col,\n      isStart: row === startPos.row && col === startPos.col,\n      isEnd: row === endPos.row && col === endPos.col,\n      isWall: false,\n      isVisited: false,\n      distance: Infinity,\n      gCost: Infinity,\n      hCost: Infinity,\n      fCost: Infinity,\n      previousNode: null,\n    };\n  }\n\n  function handleColsChange(newCols) {\n    // Just parse the input, set state\n    const cols = parseInt(newCols, 10);\n    if (cols < 5) return; // min limit\n    setNumCols(cols);\n  }\n\n  function handleRowsChange(newRows) {\n    const rows = parseInt(newRows, 10);\n    if (rows < 5) return; // min limit\n    setNumRows(rows);\n  }\n\n  // Clear path states (visited, path)\n  function clearPath() {\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const nodeDiv = document.getElementById(`node-${row}-${col}`);\n        if (nodeDiv) {\n          nodeDiv.classList.remove('node-visited');\n          nodeDiv.classList.remove('node-path');\n        }\n      }\n    }\n    const newGrid = grid.slice();\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const node = newGrid[row][col];\n        node.isVisited = false;\n        node.distance = Infinity;\n        node.gCost = Infinity;\n        node.hCost = Infinity;\n        node.fCost = Infinity;\n        node.previousNode = null;\n      }\n    }\n    setGrid(newGrid);\n  }\n\n  // Visualize selected algorithm\n  function visualize() {\n    setIsRunning(true);\n    clearPath();\n\n    const startNode = grid[startPos.row][startPos.col];\n    const endNode = grid[endPos.row][endPos.col];\n    let visitedNodesInOrder = [];\n    let path = [];\n\n    // Run the selected algorithm\n    switch (selectedAlgorithm) {\n      case 'dfs':\n        ({ visitedNodesInOrder, path } = dfs(grid, startNode, endNode));\n        break;\n      case 'dijkstra':\n        ({ visitedNodesInOrder, path } = dijkstra(grid, startNode, endNode));\n        break;\n      case 'astar':\n        ({ visitedNodesInOrder, path } = aStar(grid, startNode, endNode));\n        break;\n      case 'bfs':\n      default:\n        ({ visitedNodesInOrder, path } = bfs(grid, startNode, endNode));\n        break;\n    }\n\n    animateVisited(visitedNodesInOrder, path);\n  }\n\n  function animateVisited(visitedNodesInOrder, path) {\n    // Delay depends on speed (lower speed => bigger delay)\n    const visitDelay = 105 - speed * 10;\n\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animatePath(path);\n        }, visitDelay * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeDiv = document.getElementById(`node-${node.row}-${node.col}`);\n        if (nodeDiv) {\n          nodeDiv.classList.add('node-visited');\n        }\n      }, visitDelay * i);\n    }\n  }\n\n  function animatePath(path) {\n    const pathDelay = 150 - speed * 15;\n    for (let i = 0; i < path.length; i++) {\n      setTimeout(() => {\n        const node = path[i];\n        const nodeDiv = document.getElementById(`node-${node.row}-${node.col}`);\n        if (nodeDiv) {\n          nodeDiv.classList.remove('node-visited');\n          nodeDiv.classList.add('node-path');\n        }\n        // Unlock the UI at the end\n        if (i === path.length - 1) {\n          setIsRunning(false);\n        }\n      }, pathDelay * i);\n    }\n\n    // If path is empty, no final unlocking\n    if (!path.length) {\n      setIsRunning(false);\n    }\n  }\n\n  /************************************************\n   * Wall toggling and dragging start/end node\n   ************************************************/\n  const handleMouseDown = (row, col) => {\n    if (isRunning) return;\n    const node = grid[row][col];\n    // If clicking on start or end => drag mode\n    if (node.isStart) {\n      isDraggingStart.current = true;\n    } else if (node.isEnd) {\n      isDraggingEnd.current = true;\n    } else {\n      // Toggle wall\n      toggleWall(row, col);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (isRunning) return;\n    if (isDraggingStart.current) {\n      moveStart(row, col);\n    } else if (isDraggingEnd.current) {\n      moveEnd(row, col);\n    }\n  };\n\n  const handleMouseUp = () => {\n    isDraggingStart.current = false;\n    isDraggingEnd.current = false;\n  };\n\n  function toggleWall(row, col) {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    if (!node.isStart && !node.isEnd) {\n      node.isWall = !node.isWall;\n    }\n    setGrid(newGrid);\n  }\n\n  function moveStart(row, col) {\n    if (row === endPos.row && col === endPos.col) return; // can't overlap\n    const newGrid = grid.slice();\n    // Remove old start\n    newGrid[startPos.row][startPos.col].isStart = false;\n    newGrid[startPos.row][startPos.col].isWall = false;\n    // Set new start\n    newGrid[row][col].isStart = true;\n    newGrid[row][col].isWall = false;\n    setStartPos({ row, col });\n    setGrid(newGrid);\n  }\n\n  function moveEnd(row, col) {\n    if (row === startPos.row && col === startPos.col) return; // can't overlap\n    const newGrid = grid.slice();\n    // Remove old end\n    newGrid[endPos.row][endPos.col].isEnd = false;\n    newGrid[endPos.row][endPos.col].isWall = false;\n    // Set new end\n    newGrid[row][col].isEnd = true;\n    newGrid[row][col].isWall = false;\n    setEndPos({ row, col });\n    setGrid(newGrid);\n  }\n\n  // Render the grid with event handlers\n  function renderGrid() {\n    return grid.map((rowArray, rowIdx) => {\n      return (\n        <div key={rowIdx} className=\"row\">\n          {rowArray.map((node, colIdx) => {\n            const { row, col, isWall, isStart, isEnd } = node;\n            return (\n              <div\n                key={colIdx}\n                id={`node-${row}-${col}`}\n                className={`node\n                  ${isWall ? 'node-wall' : ''}\n                  ${isStart ? 'node-start' : ''}\n                  ${isEnd ? 'node-end' : ''}\n                `}\n                onMouseDown={() => handleMouseDown(row, col)}\n                onMouseEnter={() => handleMouseEnter(row, col)}\n                onMouseUp={handleMouseUp}\n              />\n            );\n          })}\n        </div>\n      );\n    });\n  }\n\n  return (\n    <div style={{ textAlign: 'center' }}>\n      <h2>Pathfinder</h2>\n\n      {/* Grid Size Controls */}\n      <div style={{ margin: '10px 0' }}>\n        <label>\n          Rows:\n          <input\n            type=\"number\"\n            min=\"5\"\n            max=\"50\"\n            value={numRows}\n            onChange={(e) => handleRowsChange(e.target.value)}\n            disabled={isRunning}\n            style={{ width: '60px', margin: '0 8px' }}\n          />\n        </label>\n        <label>\n          Cols:\n          <input\n            type=\"number\"\n            min=\"5\"\n            max=\"60\"\n            value={numCols}\n            onChange={(e) => handleColsChange(e.target.value)}\n            disabled={isRunning}\n            style={{ width: '60px', margin: '0 8px' }}\n          />\n        </label>\n      </div>\n\n      {/* Algorithm + Speed */}\n      <div style={{ margin: '10px 0' }}>\n        <label>\n          Algorithm:\n          <select\n            value={selectedAlgorithm}\n            onChange={(e) => setSelectedAlgorithm(e.target.value)}\n            disabled={isRunning}\n            style={{ margin: '0 8px' }}\n          >\n            {ALGORITHMS.map((algo) => (\n              <option key={algo.value} value={algo.value}>\n                {algo.label}\n              </option>\n            ))}\n          </select>\n        </label>\n\n        <label>\n          Speed:\n          <input\n            type=\"range\"\n            min=\"1\"\n            max=\"10\"\n            value={speed}\n            onChange={(e) => setSpeed(parseInt(e.target.value))}\n            disabled={isRunning}\n            style={{ margin: '0 8px' }}\n          />\n          {speed}\n        </label>\n      </div>\n\n      {/* Buttons */}\n      <button onClick={resetGrid} disabled={isRunning}>\n        Reset Grid\n      </button>\n      <button onClick={clearPath} disabled={isRunning}>\n        Clear Path\n      </button>\n      <button onClick={visualize} disabled={isRunning}>\n        Visualize\n      </button>\n\n      {/* Grid */}\n      <div style={{ marginTop: '20px', display: 'inline-block' }}>\n        {renderGrid()}\n      </div>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}