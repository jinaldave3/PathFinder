{"ast":null,"code":"var _jsxFileName = \"/Users/jinaldave/Projects/pathfinder/src/PathfindingVisualizer.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport './Node.css';\nimport { bfs, dfs, dijkstra, aStar } from './algorithms';\n\n/**\n * ALGORITHMS array to populate the dropdown.\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ALGORITHMS = [{\n  label: 'BFS',\n  value: 'bfs'\n}, {\n  label: 'DFS',\n  value: 'dfs'\n}, {\n  label: 'Dijkstra',\n  value: 'dijkstra'\n}, {\n  label: 'A*',\n  value: 'astar'\n}];\nexport default function PathfindingVisualizer() {\n  _s();\n  // Grid size\n  const [numRows, setNumRows] = useState(20);\n  const [numCols, setNumCols] = useState(40);\n\n  // Positions for start (green) and end (red)\n  const [startPos, setStartPos] = useState({\n    row: 5,\n    col: 5\n  });\n  const [endPos, setEndPos] = useState({\n    row: 15,\n    col: 30\n  });\n  const [grid, setGrid] = useState([]);\n  const [selectedAlgorithm, setSelectedAlgorithm] = useState('bfs');\n  const [isRunning, setIsRunning] = useState(false);\n  const [speed, setSpeed] = useState(5); // 1 is fastest, 10 is slowest\n\n  // Track drag states for start/end nodes\n  const isDraggingStart = useRef(false);\n  const isDraggingEnd = useRef(false);\n\n  /**\n   * Helper to compute the minimum number of rows based on start/end positions.\n   * E.g. if endPos.row = 15, then at least 16 rows are required (indexes 0..15).\n   */\n  function getMinRows() {\n    return Math.max(startPos.row, endPos.row) + 1;\n  }\n\n  /**\n   * Helper to compute the minimum number of columns based on start/end positions.\n   * E.g. if endPos.col = 30, then at least 31 columns are required (indexes 0..30).\n   */\n  function getMinCols() {\n    return Math.max(startPos.col, endPos.col) + 1;\n  }\n\n  /**\n   * Whenever the grid size changes, rebuild the grid.\n   */\n  useEffect(() => {\n    resetGrid();\n    // eslint-disable-next-line\n  }, [numRows, numCols, startPos, endPos]);\n  function resetGrid() {\n    const newGrid = [];\n    for (let row = 0; row < numRows; row++) {\n      const currentRow = [];\n      for (let col = 0; col < numCols; col++) {\n        currentRow.push(createNode(row, col));\n      }\n      newGrid.push(currentRow);\n    }\n    setGrid(newGrid);\n  }\n  function createNode(row, col) {\n    return {\n      row,\n      col,\n      isStart: row === startPos.row && col === startPos.col,\n      isEnd: row === endPos.row && col === endPos.col,\n      isWall: false,\n      isVisited: false,\n      distance: Infinity,\n      gCost: Infinity,\n      hCost: Infinity,\n      fCost: Infinity,\n      previousNode: null\n    };\n  }\n\n  /**\n   * Prevent the user from entering a row count below the minimum needed to keep nodes in-bounds.\n   */\n  function handleRowsChange(value) {\n    if (isRunning) return;\n    const newRows = parseInt(value, 10);\n    // clamp\n    const minR = getMinRows(); // e.g. 16 if endPos.row=15\n    if (newRows < minR) {\n      setNumRows(minR);\n    } else {\n      setNumRows(newRows);\n    }\n  }\n\n  /**\n   * Prevent the user from entering a col count below the minimum needed to keep nodes in-bounds.\n   */\n  function handleColsChange(value) {\n    if (isRunning) return;\n    const newCols = parseInt(value, 10);\n    // clamp\n    const minC = getMinCols(); // e.g. 31 if endPos.col=30\n    if (newCols < minC) {\n      setNumCols(minC);\n    } else {\n      setNumCols(newCols);\n    }\n  }\n\n  // Clear path states (visited, path)\n  function clearPath() {\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const nodeDiv = document.getElementById(`node-${row}-${col}`);\n        if (nodeDiv) {\n          nodeDiv.classList.remove('node-visited');\n          nodeDiv.classList.remove('node-path');\n        }\n      }\n    }\n    const newGrid = grid.slice();\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const node = newGrid[row][col];\n        node.isVisited = false;\n        node.distance = Infinity;\n        node.gCost = Infinity;\n        node.hCost = Infinity;\n        node.fCost = Infinity;\n        node.previousNode = null;\n      }\n    }\n    setGrid(newGrid);\n  }\n\n  // Visualize selected algorithm\n  function visualize() {\n    setIsRunning(true);\n    clearPath();\n    const startNode = grid[startPos.row][startPos.col];\n    const endNode = grid[endPos.row][endPos.col];\n    let visitedNodesInOrder = [];\n    let path = [];\n\n    // Run the selected algorithm\n    switch (selectedAlgorithm) {\n      case 'dfs':\n        ({\n          visitedNodesInOrder,\n          path\n        } = dfs(grid, startNode, endNode));\n        break;\n      case 'dijkstra':\n        ({\n          visitedNodesInOrder,\n          path\n        } = dijkstra(grid, startNode, endNode));\n        break;\n      case 'astar':\n        ({\n          visitedNodesInOrder,\n          path\n        } = aStar(grid, startNode, endNode));\n        break;\n      case 'bfs':\n      default:\n        ({\n          visitedNodesInOrder,\n          path\n        } = bfs(grid, startNode, endNode));\n        break;\n    }\n    animateVisited(visitedNodesInOrder, path);\n  }\n  function animateVisited(visitedNodesInOrder, path) {\n    // Delay depends on speed (lower speed => bigger delay)\n    const visitDelay = 105 - speed * 10;\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animatePath(path);\n        }, visitDelay * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeDiv = document.getElementById(`node-${node.row}-${node.col}`);\n        if (nodeDiv) {\n          nodeDiv.classList.add('node-visited');\n        }\n      }, visitDelay * i);\n    }\n  }\n  function animatePath(path) {\n    const pathDelay = 150 - speed * 15;\n    for (let i = 0; i < path.length; i++) {\n      setTimeout(() => {\n        const node = path[i];\n        const nodeDiv = document.getElementById(`node-${node.row}-${node.col}`);\n        if (nodeDiv) {\n          nodeDiv.classList.remove('node-visited');\n          nodeDiv.classList.add('node-path');\n        }\n        // Unlock the UI at the end\n        if (i === path.length - 1) {\n          setIsRunning(false);\n        }\n      }, pathDelay * i);\n    }\n\n    // If path is empty => no final unlocking\n    if (!path.length) {\n      setIsRunning(false);\n    }\n  }\n\n  /************************************************\n   * Wall toggling and dragging start/end node\n   ************************************************/\n  const handleMouseDown = (row, col) => {\n    if (isRunning) return;\n    const node = grid[row][col];\n    // If clicking on start or end => drag mode\n    if (node.isStart) {\n      isDraggingStart.current = true;\n    } else if (node.isEnd) {\n      isDraggingEnd.current = true;\n    } else {\n      // Toggle wall\n      toggleWall(row, col);\n    }\n  };\n  const handleMouseEnter = (row, col) => {\n    if (isRunning) return;\n    if (isDraggingStart.current) {\n      moveStart(row, col);\n    } else if (isDraggingEnd.current) {\n      moveEnd(row, col);\n    }\n  };\n  const handleMouseUp = () => {\n    isDraggingStart.current = false;\n    isDraggingEnd.current = false;\n  };\n  function toggleWall(row, col) {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    if (!node.isStart && !node.isEnd) {\n      node.isWall = !node.isWall;\n    }\n    setGrid(newGrid);\n  }\n  function moveStart(row, col) {\n    if (row === endPos.row && col === endPos.col) return; // can't overlap\n    const newGrid = grid.slice();\n    // Remove old start\n    newGrid[startPos.row][startPos.col].isStart = false;\n    newGrid[startPos.row][startPos.col].isWall = false;\n    // Set new start\n    newGrid[row][col].isStart = true;\n    newGrid[row][col].isWall = false;\n    setStartPos({\n      row,\n      col\n    });\n    setGrid(newGrid);\n  }\n  function moveEnd(row, col) {\n    if (row === startPos.row && col === startPos.col) return; // can't overlap\n    const newGrid = grid.slice();\n    // Remove old end\n    newGrid[endPos.row][endPos.col].isEnd = false;\n    newGrid[endPos.row][endPos.col].isWall = false;\n    // Set new end\n    newGrid[row][col].isEnd = true;\n    newGrid[row][col].isWall = false;\n    setEndPos({\n      row,\n      col\n    });\n    setGrid(newGrid);\n  }\n\n  // Render the grid with event handlers\n  function renderGrid() {\n    return grid.map((rowArray, rowIdx) => {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"row\",\n        children: rowArray.map((node, colIdx) => {\n          const {\n            row,\n            col,\n            isWall,\n            isStart,\n            isEnd\n          } = node;\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            id: `node-${row}-${col}`,\n            className: `node\n                  ${isWall ? 'node-wall' : ''}\n                  ${isStart ? 'node-start' : ''}\n                  ${isEnd ? 'node-end' : ''}\n                `,\n            onMouseDown: () => handleMouseDown(row, col),\n            onMouseEnter: () => handleMouseEnter(row, col),\n            onMouseUp: handleMouseUp\n          }, colIdx, false, {\n            fileName: _jsxFileName,\n            lineNumber: 289,\n            columnNumber: 15\n          }, this);\n        })\n      }, rowIdx, false, {\n        fileName: _jsxFileName,\n        lineNumber: 285,\n        columnNumber: 9\n      }, this);\n    });\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      textAlign: 'center'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Pathfinder\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 310,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        margin: '10px 0'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        children: [\"Rows:\", /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          min: getMinRows(),\n          max: \"50\",\n          value: numRows,\n          onChange: e => handleRowsChange(e.target.value),\n          disabled: isRunning,\n          style: {\n            width: '60px',\n            margin: '0 8px'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 316,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 314,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n        children: [\"Cols:\", /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          min: getMinCols(),\n          max: \"60\",\n          value: numCols,\n          onChange: e => handleColsChange(e.target.value),\n          disabled: isRunning,\n          style: {\n            width: '60px',\n            margin: '0 8px'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 328,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 326,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 313,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        margin: '10px 0'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        children: [\"Algorithm:\", /*#__PURE__*/_jsxDEV(\"select\", {\n          value: selectedAlgorithm,\n          onChange: e => setSelectedAlgorithm(e.target.value),\n          disabled: isRunning,\n          style: {\n            margin: '0 8px'\n          },\n          children: ALGORITHMS.map(algo => /*#__PURE__*/_jsxDEV(\"option\", {\n            value: algo.value,\n            children: algo.label\n          }, algo.value, false, {\n            fileName: _jsxFileName,\n            lineNumber: 351,\n            columnNumber: 15\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 344,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 342,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n        children: [\"Speed:\", /*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"range\",\n          min: \"1\",\n          max: \"10\",\n          value: speed,\n          onChange: e => setSpeed(parseInt(e.target.value)),\n          disabled: isRunning,\n          style: {\n            margin: '0 8px'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 360,\n          columnNumber: 11\n        }, this), speed]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 358,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 341,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: resetGrid,\n      disabled: isRunning,\n      children: \"Reset Grid\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 374,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: clearPath,\n      disabled: isRunning,\n      children: \"Clear Path\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 377,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: visualize,\n      disabled: isRunning,\n      children: \"Visualize\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 380,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginTop: '20px',\n        display: 'inline-block'\n      },\n      children: renderGrid()\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 385,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 309,\n    columnNumber: 5\n  }, this);\n}\n_s(PathfindingVisualizer, \"FLQSYPWXnVFPYC+BJEmSUON2n3M=\");\n_c = PathfindingVisualizer;\nvar _c;\n$RefreshReg$(_c, \"PathfindingVisualizer\");","map":{"version":3,"names":["React","useState","useEffect","useRef","bfs","dfs","dijkstra","aStar","jsxDEV","_jsxDEV","ALGORITHMS","label","value","PathfindingVisualizer","_s","numRows","setNumRows","numCols","setNumCols","startPos","setStartPos","row","col","endPos","setEndPos","grid","setGrid","selectedAlgorithm","setSelectedAlgorithm","isRunning","setIsRunning","speed","setSpeed","isDraggingStart","isDraggingEnd","getMinRows","Math","max","getMinCols","resetGrid","newGrid","currentRow","push","createNode","isStart","isEnd","isWall","isVisited","distance","Infinity","gCost","hCost","fCost","previousNode","handleRowsChange","newRows","parseInt","minR","handleColsChange","newCols","minC","clearPath","nodeDiv","document","getElementById","classList","remove","slice","node","visualize","startNode","endNode","visitedNodesInOrder","path","animateVisited","visitDelay","i","length","setTimeout","animatePath","add","pathDelay","handleMouseDown","current","toggleWall","handleMouseEnter","moveStart","moveEnd","handleMouseUp","renderGrid","map","rowArray","rowIdx","className","children","colIdx","id","onMouseDown","onMouseEnter","onMouseUp","fileName","_jsxFileName","lineNumber","columnNumber","style","textAlign","margin","type","min","onChange","e","target","disabled","width","algo","onClick","marginTop","display","_c","$RefreshReg$"],"sources":["/Users/jinaldave/Projects/pathfinder/src/PathfindingVisualizer.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport './Node.css';\nimport { bfs, dfs, dijkstra, aStar } from './algorithms';\n\n/**\n * ALGORITHMS array to populate the dropdown.\n */\nconst ALGORITHMS = [\n  { label: 'BFS', value: 'bfs' },\n  { label: 'DFS', value: 'dfs' },\n  { label: 'Dijkstra', value: 'dijkstra' },\n  { label: 'A*', value: 'astar' },\n];\n\nexport default function PathfindingVisualizer() {\n  // Grid size\n  const [numRows, setNumRows] = useState(20);\n  const [numCols, setNumCols] = useState(40);\n\n  // Positions for start (green) and end (red)\n  const [startPos, setStartPos] = useState({ row: 5, col: 5 });\n  const [endPos, setEndPos] = useState({ row: 15, col: 30 });\n\n  const [grid, setGrid] = useState([]);\n  const [selectedAlgorithm, setSelectedAlgorithm] = useState('bfs');\n  const [isRunning, setIsRunning] = useState(false);\n  const [speed, setSpeed] = useState(5); // 1 is fastest, 10 is slowest\n\n  // Track drag states for start/end nodes\n  const isDraggingStart = useRef(false);\n  const isDraggingEnd = useRef(false);\n\n  /**\n   * Helper to compute the minimum number of rows based on start/end positions.\n   * E.g. if endPos.row = 15, then at least 16 rows are required (indexes 0..15).\n   */\n  function getMinRows() {\n    return Math.max(startPos.row, endPos.row) + 1;\n  }\n\n  /**\n   * Helper to compute the minimum number of columns based on start/end positions.\n   * E.g. if endPos.col = 30, then at least 31 columns are required (indexes 0..30).\n   */\n  function getMinCols() {\n    return Math.max(startPos.col, endPos.col) + 1;\n  }\n\n  /**\n   * Whenever the grid size changes, rebuild the grid.\n   */\n  useEffect(() => {\n    resetGrid();\n    // eslint-disable-next-line\n  }, [numRows, numCols, startPos, endPos]);\n\n  function resetGrid() {\n    const newGrid = [];\n    for (let row = 0; row < numRows; row++) {\n      const currentRow = [];\n      for (let col = 0; col < numCols; col++) {\n        currentRow.push(createNode(row, col));\n      }\n      newGrid.push(currentRow);\n    }\n    setGrid(newGrid);\n  }\n\n  function createNode(row, col) {\n    return {\n      row,\n      col,\n      isStart: row === startPos.row && col === startPos.col,\n      isEnd: row === endPos.row && col === endPos.col,\n      isWall: false,\n      isVisited: false,\n      distance: Infinity,\n      gCost: Infinity,\n      hCost: Infinity,\n      fCost: Infinity,\n      previousNode: null,\n    };\n  }\n\n  /**\n   * Prevent the user from entering a row count below the minimum needed to keep nodes in-bounds.\n   */\n  function handleRowsChange(value) {\n    if (isRunning) return;\n    const newRows = parseInt(value, 10);\n    // clamp\n    const minR = getMinRows(); // e.g. 16 if endPos.row=15\n    if (newRows < minR) {\n      setNumRows(minR);\n    } else {\n      setNumRows(newRows);\n    }\n  }\n\n  /**\n   * Prevent the user from entering a col count below the minimum needed to keep nodes in-bounds.\n   */\n  function handleColsChange(value) {\n    if (isRunning) return;\n    const newCols = parseInt(value, 10);\n    // clamp\n    const minC = getMinCols(); // e.g. 31 if endPos.col=30\n    if (newCols < minC) {\n      setNumCols(minC);\n    } else {\n      setNumCols(newCols);\n    }\n  }\n\n  // Clear path states (visited, path)\n  function clearPath() {\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const nodeDiv = document.getElementById(`node-${row}-${col}`);\n        if (nodeDiv) {\n          nodeDiv.classList.remove('node-visited');\n          nodeDiv.classList.remove('node-path');\n        }\n      }\n    }\n    const newGrid = grid.slice();\n    for (let row = 0; row < numRows; row++) {\n      for (let col = 0; col < numCols; col++) {\n        const node = newGrid[row][col];\n        node.isVisited = false;\n        node.distance = Infinity;\n        node.gCost = Infinity;\n        node.hCost = Infinity;\n        node.fCost = Infinity;\n        node.previousNode = null;\n      }\n    }\n    setGrid(newGrid);\n  }\n\n  // Visualize selected algorithm\n  function visualize() {\n    setIsRunning(true);\n    clearPath();\n\n    const startNode = grid[startPos.row][startPos.col];\n    const endNode = grid[endPos.row][endPos.col];\n    let visitedNodesInOrder = [];\n    let path = [];\n\n    // Run the selected algorithm\n    switch (selectedAlgorithm) {\n      case 'dfs':\n        ({ visitedNodesInOrder, path } = dfs(grid, startNode, endNode));\n        break;\n      case 'dijkstra':\n        ({ visitedNodesInOrder, path } = dijkstra(grid, startNode, endNode));\n        break;\n      case 'astar':\n        ({ visitedNodesInOrder, path } = aStar(grid, startNode, endNode));\n        break;\n      case 'bfs':\n      default:\n        ({ visitedNodesInOrder, path } = bfs(grid, startNode, endNode));\n        break;\n    }\n\n    animateVisited(visitedNodesInOrder, path);\n  }\n\n  function animateVisited(visitedNodesInOrder, path) {\n    // Delay depends on speed (lower speed => bigger delay)\n    const visitDelay = 105 - speed * 10;\n\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animatePath(path);\n        }, visitDelay * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeDiv = document.getElementById(`node-${node.row}-${node.col}`);\n        if (nodeDiv) {\n          nodeDiv.classList.add('node-visited');\n        }\n      }, visitDelay * i);\n    }\n  }\n\n  function animatePath(path) {\n    const pathDelay = 150 - speed * 15;\n    for (let i = 0; i < path.length; i++) {\n      setTimeout(() => {\n        const node = path[i];\n        const nodeDiv = document.getElementById(`node-${node.row}-${node.col}`);\n        if (nodeDiv) {\n          nodeDiv.classList.remove('node-visited');\n          nodeDiv.classList.add('node-path');\n        }\n        // Unlock the UI at the end\n        if (i === path.length - 1) {\n          setIsRunning(false);\n        }\n      }, pathDelay * i);\n    }\n\n    // If path is empty => no final unlocking\n    if (!path.length) {\n      setIsRunning(false);\n    }\n  }\n\n  /************************************************\n   * Wall toggling and dragging start/end node\n   ************************************************/\n  const handleMouseDown = (row, col) => {\n    if (isRunning) return;\n    const node = grid[row][col];\n    // If clicking on start or end => drag mode\n    if (node.isStart) {\n      isDraggingStart.current = true;\n    } else if (node.isEnd) {\n      isDraggingEnd.current = true;\n    } else {\n      // Toggle wall\n      toggleWall(row, col);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (isRunning) return;\n    if (isDraggingStart.current) {\n      moveStart(row, col);\n    } else if (isDraggingEnd.current) {\n      moveEnd(row, col);\n    }\n  };\n\n  const handleMouseUp = () => {\n    isDraggingStart.current = false;\n    isDraggingEnd.current = false;\n  };\n\n  function toggleWall(row, col) {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    if (!node.isStart && !node.isEnd) {\n      node.isWall = !node.isWall;\n    }\n    setGrid(newGrid);\n  }\n\n  function moveStart(row, col) {\n    if (row === endPos.row && col === endPos.col) return; // can't overlap\n    const newGrid = grid.slice();\n    // Remove old start\n    newGrid[startPos.row][startPos.col].isStart = false;\n    newGrid[startPos.row][startPos.col].isWall = false;\n    // Set new start\n    newGrid[row][col].isStart = true;\n    newGrid[row][col].isWall = false;\n    setStartPos({ row, col });\n    setGrid(newGrid);\n  }\n\n  function moveEnd(row, col) {\n    if (row === startPos.row && col === startPos.col) return; // can't overlap\n    const newGrid = grid.slice();\n    // Remove old end\n    newGrid[endPos.row][endPos.col].isEnd = false;\n    newGrid[endPos.row][endPos.col].isWall = false;\n    // Set new end\n    newGrid[row][col].isEnd = true;\n    newGrid[row][col].isWall = false;\n    setEndPos({ row, col });\n    setGrid(newGrid);\n  }\n\n  // Render the grid with event handlers\n  function renderGrid() {\n    return grid.map((rowArray, rowIdx) => {\n      return (\n        <div key={rowIdx} className=\"row\">\n          {rowArray.map((node, colIdx) => {\n            const { row, col, isWall, isStart, isEnd } = node;\n            return (\n              <div\n                key={colIdx}\n                id={`node-${row}-${col}`}\n                className={`node\n                  ${isWall ? 'node-wall' : ''}\n                  ${isStart ? 'node-start' : ''}\n                  ${isEnd ? 'node-end' : ''}\n                `}\n                onMouseDown={() => handleMouseDown(row, col)}\n                onMouseEnter={() => handleMouseEnter(row, col)}\n                onMouseUp={handleMouseUp}\n              />\n            );\n          })}\n        </div>\n      );\n    });\n  }\n\n  return (\n    <div style={{ textAlign: 'center' }}>\n      <h2>Pathfinder</h2>\n\n      {/* Grid Size Controls */}\n      <div style={{ margin: '10px 0' }}>\n        <label>\n          Rows:\n          <input\n            type=\"number\"\n            min={getMinRows()}\n            max=\"50\"\n            value={numRows}\n            onChange={(e) => handleRowsChange(e.target.value)}\n            disabled={isRunning}\n            style={{ width: '60px', margin: '0 8px' }}\n          />\n        </label>\n        <label>\n          Cols:\n          <input\n            type=\"number\"\n            min={getMinCols()}\n            max=\"60\"\n            value={numCols}\n            onChange={(e) => handleColsChange(e.target.value)}\n            disabled={isRunning}\n            style={{ width: '60px', margin: '0 8px' }}\n          />\n        </label>\n      </div>\n\n      {/* Algorithm + Speed */}\n      <div style={{ margin: '10px 0' }}>\n        <label>\n          Algorithm:\n          <select\n            value={selectedAlgorithm}\n            onChange={(e) => setSelectedAlgorithm(e.target.value)}\n            disabled={isRunning}\n            style={{ margin: '0 8px' }}\n          >\n            {ALGORITHMS.map((algo) => (\n              <option key={algo.value} value={algo.value}>\n                {algo.label}\n              </option>\n            ))}\n          </select>\n        </label>\n\n        <label>\n          Speed:\n          <input\n            type=\"range\"\n            min=\"1\"\n            max=\"10\"\n            value={speed}\n            onChange={(e) => setSpeed(parseInt(e.target.value))}\n            disabled={isRunning}\n            style={{ margin: '0 8px' }}\n          />\n          {speed}\n        </label>\n      </div>\n\n      {/* Buttons */}\n      <button onClick={resetGrid} disabled={isRunning}>\n        Reset Grid\n      </button>\n      <button onClick={clearPath} disabled={isRunning}>\n        Clear Path\n      </button>\n      <button onClick={visualize} disabled={isRunning}>\n        Visualize\n      </button>\n\n      {/* Grid */}\n      <div style={{ marginTop: '20px', display: 'inline-block' }}>\n        {renderGrid()}\n      </div>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}